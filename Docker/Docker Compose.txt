============================================================
Docker Compose файл
============================================================

-----------------
version: '3'

services:
  app:
    build: ./app
  mongo:
    image: mongo
-----------------

Где app, mongo - названия сервисов(названия выбираем мы);
image - возьмет образ mongo локально, или же скачает с docker hub;
build - создание кастомного образа на основании docker файла;
./app - это местоположение Docker файла для этого приложения

После создания Docker файла и Docker-compose.yml файла, можно запустить оба сервиса, используя одну команду:

docker-compose up

Когда сервисы уже не нужны, их можно остановить одной командой:

docker-compose down

=========================
Пример DOckerfile с загрузкой стороннего пакета Python
---
FROM python:alpine

WORKDIR /app

RUN pip install pymongo

COPY . .

CMD [ "python", "main.py" ]
---

Находясь в папке с yml файлом сборка сервисов:

docker-compose up

-----------------------

Запуск контейнеров в фоновом режиме:

docker-compose up -d


---

docker-compose down					Останавливает все контейнеры, которые касаются docker-compose и удалить их

ПЕРЕСОЗДАНИЕ ОБРАЗА:

docker-compose up -d --build

Посмотреть логи контейнера:

docker logs 972d8b602054			(с id контейнера)


ПРИМЕР DOCKERFILE для\ фронтенд сервиса
***
FROM node:alpine

WORKDIR /app

EXPOSE 3000

COPY package*.json ./

RUN npm install

COPY . .

CMD ["npm", "run", "dev"]
***
EXPOSE - ни на что не влияет, но помогает другим разработчиками понять, на каком порту открывается приложения
COPY package*.json ./ - копирует два файла - package.json и package-lock.json в дирректорию /app
до комманды npm install на нет необходимости копировать все файлы приложения - достаточно только 2 - package*.json
Поэтому остальные файлы мы копируем после npm install. Это служит для более эффективного построения слоев приложения
Так как файлы приложения могуь меняться часто, а установка новых зависимостей - редко
Поэтому мы выносим этам загрузки зависимостей. И при перестроении образа Docker сможет переиспользовать слои предыдщие - с зависимостями
CMD ["npm", "run", "dev"] - запуск сервера в режиме разработки

Затем создаем образ frontend^

docker build . -t time-app-frontend

***
После этого уже можно запустить контейнер с frontend приложением:
docker run -p 3000:3000 time-app-frontend
***
























