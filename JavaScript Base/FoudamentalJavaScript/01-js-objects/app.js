//////////////////////////////////////////////////////////////////////////
// Объекты
//////////////////////////////////////////////////////////////////////////

const developer = {
    name: 'Vasiliy',
    surname: 'Petrov',
    age: 30,
    skills: ['JavaScript', 'TypeScript', 'CSS'],
    isMaried: false
};

console.log(developer.name);
developer.isMaried = true;
// delete developer.isMaried;          // удаление ключа со значением из объекта(этот оператор не кросбраузерный)
// в Safary с нми могут быть нюансы
console.log(developer.isMaried);

// доступ по переменной, это второй вариант доступа, либо чере . либо так
console.log(developer['age']);

//////////////////////////////////////////////////////////////////////////
// Оператор in
//////////////////////////////////////////////////////////////////////////

// проверка наличия ключа в объекте
console.log('name' in developer);

//////////////////////////////////////////////////////////////////////////
// Цикл for in
//////////////////////////////////////////////////////////////////////////

// Используется для прохождения по объекту (переменная получает значения ключей )
for (let prop in developer) {
    console.log(prop);  // напечатает ключи
}

for (let prop in developer) {
    console.log(prop, developer[prop]);  // напечатает ключи и значения
}

//////////////////////////////////////////////////////////////////////////
// Цикл for of
//////////////////////////////////////////////////////////////////////////

// тоже самое, что in, только получает значения элементов а не значения ключей

const numbers = [1, 2, 3, 4, 5];
for (let number of numbers) {
    console.log(number);
}

//////////////////////////////////////////////////////////////////////////
// Методы объекта, контекст(this)
//////////////////////////////////////////////////////////////////////////

const developer2 = {
    name: 'Vasiliy',
    surname: 'Petrov',
    age: 30,
    skills: ['JavaScript', 'TypeScript', 'CSS'],
    isMaried: false,
    addAge() {
        this.age++;
        console.log(this);
    },
    getMarried() {
        this.isMaried = true;
    },
    getDivorced() {
        this.isMaried = false;
    }
};

developer2.addAge();

// Методы прототипа Object:
developer2.hasOwnProperty('name');      // говорит, есть ли у нашего объекта собственное свойство

//////////////////////////////////////////////////////////////////////////
// Встроенные методы строк
//////////////////////////////////////////////////////////////////////////

const str = 'Hello World';
console.log(str.toLowerCase());         // преобразовать буквы к нижнему регистру
console.log(str.toUpperCase());         // преобразовать буквы к верхнему регистру

// эти методы часто используются, когда мы принимаем пользовательский ввод, 
// и нам необходимо его с чем то сверить. мы приводим буквы к одному регистру, 
// чтобы не зависеть от регистра(когда это не требуется)

///////////////
// Методы, позволяющий проверить, есть ли в строке то или инное слово
console.log(str.includes('world'));     // вернет булево значение

// ранее использовался другой метод - indexOf(), может до сих пор встречаться в легаси
console.log(str.indexOf('World'));      // вернет число(6) - индекс начала входения данной подстроки

// можно и так, чтобы не зависеть от регистра
console.log(str.toLowerCase().includes('world'));

// срез - slice()

console.log(str.slice(0, 5));           // выводит первые пять символов
console.log(str.slice(6));              // с шестой и до конца строки

// преобразование строик к массиву
console.log(str.split(' '));               // принимает разделитель (пробел), сделает массив с двумя словами

// а теперь соединим ихз обратно, добавив пробел, знак | и еще один пробел
console.log(str.split(' ').join(' | ')); 

// chaining - это когда мы применяем несколько методов через точку

// trim() - позволяет удалять пробелы, есть несколько вариантов

//////////////////////////////////////////////////////////////////////////
// Встроенные методы чисел
//////////////////////////////////////////////////////////////////////////

const num = 18000.15555;

console.log(num.toFixed());                 // округление, если ничего не передать - отбрасывает дробную часть
console.log(num.toFixed(2));                // округление до двух точек после запятой

console.log(num.toLocaleString());          // если ничего не передавать, число отпределится в локали по умолчанию
console.log(num.toLocaleString('ru-Ru'));   // для российской локали

//////////////////////////////////////////////////////////////////////////
// Встроенные методы массивов
//////////////////////////////////////////////////////////////////////////

const numbers4 = [1, 2, 3, 4];

// pop, push        удаление и вставка элемента в конец массива
// shift, unshift   добавляют элемент в начало массива или удаляют из начала массива

console.log(numbers4.includes(4));           // проверяет, есть ли в массиве такое значение
numbers4.indexOf(2);                        // вернет индекс вхождения элемента, если найдет элемент (1)
numbers4.indexOf(9);            // -1, так как нет такого элемента

console.log(numbers4.slice(0, 2));      // срез, [1, 2]

const nums2 = numbers4.concat([6, 7, 8]);        // конкатенация
console.log(nums2);

console.log(numbers4.join(', '));       // вернет строку со всеми элементами массива с заданным разделителем

//////////////////////////////////////////////////////////////////////////
// Объекты ошибки и работа с ошибками
//////////////////////////////////////////////////////////////////////////

// ReferenceError означает, что мы пытаемся использовать имя или ключ объекта, который не существует
// SyntaxError означает ошибку в коде, что мы пропустили например скобку или кавычку

// TypeError
// const x = 1;
// x();

// Создаем свою ошибку(пробрасываем)
// throw new Error означает - пробрось новую ошибку
function sum(a, b) {
    if(typeof a !== 'number' || typeof b !== 'number') {
        throw new Error('В функцию не переданы числа для сложения');
    }
    return a + b;
}

// ловим ошибку, чтобы можно было продолжить выполнение программы
try {
    sum();
} catch (err) {
    console.error(err.message);     // выведем только само сообщение ошибки, без параметров
}

console.log('End');
 
//////////////////////////////////////////////////////////////////////////
// Объект регулярного выражения
//////////////////////////////////////////////////////////////////////////
// Два способа создания регулярного выражения
const regex1 = /\w+/;
const regex2 = new RegExp('\\w+');      // обратный слэш(\) нужен для экранирования

const str3 = 'JavaScript is cool language. Everybody should learn JavaScript';
console.log(/JavaScript/.test(str3));   // вернет true или false, в зависимости есть ли искомое слово
console.log(/javascript/i.test(str3));  // (i) означает искать без учета регистра(тоже вернет булево значение)

// строковые методы для работы с регулярными выражениями
console.log(str3.replace(/javascript/i, 'php'));    // изменяет только одно вхождение
console.log(str3.replace(/javascript/gi, 'php'));    // изменяет все вхождения

// g - глобальный поиск(все вхождения), i - без учета регистра

console.log(str3.match(/javascript/gi));         // в отличие от test() вернет массив с информацией или null 

// пример регулярного выражения для валидации email
const validateEmail = (email) => {
    return String(email)
      .toLowerCase()
      .match(
        /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/
      );
};

// то же самое, но в виде функции
// function validateEmail(email) {
//     const re = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
//     return re.test(String(email).toLowerCase());
// }


