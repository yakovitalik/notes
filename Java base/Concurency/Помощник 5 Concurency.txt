*******************************************************************************
				CONCURENCY
*******************************************************************************
=======================================
Общее
=======================================

Превратить поток исполнения в потоковый демон можно, сделав следующий вызов:
t.setDaemon(true);


Основное местов библиотеке:
java. util. concurrent
***************************************
=======================================
java.lanq.Thread
=======================================
* Thread (Runnable target)
	Конструирует новый поток исполнения, вызывающий метод run () для указанного целевого
	объекта.
* void start ()
	Запускает поток исполнения, инициируя вызов метода run () . Этот метод немедленно возвращает
	управление. Новый поток исполняется параллельно.
* void run()
	Вызывает метод run () для связанного с ним объекта типа RunnaЬle.
* static void sleep (long millis)
	Переходит в состояние ожидания на заданное число миллисекунд.
* static void yield()
	Вынуждает текущий исполняемый поток уступить управление другому потоку. Следует, однако,
	иметь в виду, что этот метод - статический.

* void join()
	Ожидает завершения указанного потока.
* void join(lonq millis)
	Ожидает завершения указанного потока исполнения или истечения заданного периода времени.
* Thread.State qetState()
	Получает состояние данного потока исполнения. Может принимать значения NEW, RUNNAВLE,
	BLOCКED, WAITING, TIМED WAITING или TERМINATED.
* void stop()
	Останавливает поток исполнения. Этот метод не рекомендован к применению.
* void suspend()
	Временно приостанавливает поток исполнения. Этот метод не рекомендован к применению.
* void resume()
	Возобновляет поток исполнения. Вызывается только после вызова метода suspend (). Этот метод
	не рекомендован к применению.

* void interrupt()
	Посылает потоку исполнения запрос на прерывание. Признак состояния прерывания потока исполнения
	устанавливается равным логическому значению true. Если поток в данный момент
	блокирован вызовом метода sleep (), генерируется исключение типа InterruptedException.
* static boolean interrupted()
	Проверяет, был ли прерван текущий поток исполнения. Следует, однако, иметь в виду, что это статический
	метод. Его вызов имеет побочный эффект: признак состояния прерывания текущего потока
	исполнения устанавливается равным логическому значению false.
* boolean islnterrupted()
	Проверяет, был ли прерван поток исполнения. В отличие от статического метода interrupted (),
	вызов этого метода не изменяет состояние прерывания потока исполнения.
* static Thread currentТhread()
	Возвращает объект типа Тhread, представляющий текущий поток исполнения.

* void setDaemon(boolean isDaemon)
	Помечает данный поток исполнения как демон или пользовательский поток. Этот метод должен
	вызываться перед запуском потока исполнения.

* static void setDefaultUncaughtExceptionHandler
		(Тhread. UncaughtExceptionНandler handler)
* static Тhread.UncaughtExceptionHandler getDefaultUncaughtException
		Handler()
	Устанавливают или nолучают обработчик no умолчанию для необрабатываемых исключений.
* void setUncaughtExceptionHandler(Тhread.UncaughtException
		Handler handler)
* Тhread.UncaughtExceptionНandler getUncaughtExceptionHandler() 5
	Устанавливают или nолучают обработчик для необрабатываемых исключений. Если обработчик вообще
	не установлен, таким обработчиком становится объект rpynnы nотоков исnолнения.

* void setPriority(int newPriority)
	Устанавливает приоритет потока исполнения. Приоритет должен находиться в пределах
	от Thread.MIN_PRIORITY до Thread.МAX_PRIORIТY. Для нормального приоритета указывается
	значение Thread.NORМ PRIORITY.
* static int MIN PRIORITY
	Минимальный приоритет, который может иметь объект типа Thread. Значение минимального приоритета
	равно 1.
* static int NORМ PRIORITY
	Приоритет объекта типа Thread по умолчанию. Значение нормального приоритета по умолчанию
	равно 5.
* static int МАХ PRIORITY
	Максимальный приоритет, который может иметь объект типа Thread. Значение максимального
	приоритета равно 10.

***************************************
=======================================
java.lang.Runnable
=======================================
* void run()
	Этот метод следует переопределить и ввести в него инструкции для исполнения требуемой задачи
	в потоке.
***************************************
=======================================
java.lang.Тhread.UncaughtExceptionНandler
=======================================
* void uncaughtException(Тhread t, Throwable е)
	Оnределяется для nротоколирования сnециального отчета no завершении nотока исnолнения с необрабатываемым
	исключением.

***************************************
=======================================
java.lang.ThreadGroup
=======================================
* void uncaughtException (Тhread t, ТhrowaЬle е)
	Этот метод вызывается из родительской rpynnы nотоков, если таковая имеется, или же вызывается
	обработчик no умолчанию из класса Тhread, если таковой имеется, а иначе выводится трассировка
	стека в стандартный nоток сообщений об ошибках. !Но если е - объект тиnа ТhreadDeath, то
	трассировка стека nодавляется. Объекты тиnа ТhreadDeath формируются устаревшим и не рекомендованным
	к nрименению методом stop().

***************************************
=======================================
java.util.concurrent.locks.Lock
=======================================
* void lock ()
	Захватывает блокировку. Если же в данный момент она захвачена другим потоком , текущий поток
	блокируется .
* void unlock ()
	Снимает блокировку.

* Condition newCondition()
	Возвращает объект условия, связанный с данной блокировкой.
***************************************
=======================================
java.util.concurrent.locks.ReentrantLock
=======================================
* ReentrantLock()
	Конструирует объект реентерабельной блокировки, которая может быть использована для защиты
	критического раздела кода.
* ReentrantLock (boolean fair)
	Конструирует объект реентерабельной блокировки с заданным правилом равноправия. Равноправная
	блокировка отдает предпочтение потоку исполнения, ожидающему дольше всех. Но такое
	равноправие может отрицательно сказаться на производительности. Поэтому по умолчанию равноправия
	от блокировок не требуется .
***************************************
=======================================
java.util.concurrent.locks.Condition
=======================================
* void await()
	Вводит поток исполнения в набор ожидания по данному условию.
* void signalAll()
	Разблокирует все потоки исполнения в наборе ожидания по данному условию.
• void signal()
	Разблокирует один произвольно выбранный поток исполнения в наборе ожидания по данному условию.
***************************************
=======================================
java.lang.Object
=======================================
* void notifyAll()
	Разблокирует nотоки исnолнения, вызвавшие метод wai t () для данного объекта. Может быть вызван
	только из тела синхронизированного метода или блока кода. Генерирует исключение тиnа
	IlleqalМonitorStateException, если поток исполнения не владеет блокировкой данного
	объекта.
* void notify()
	Разблокирует один nроизвольно выбранный nоток исnолнения среди nотоков, вызвавших метод
	wait() для данного объекта. Может быть вызван только из тела синхронизированного метода или
	блока кода. Генерирует исключение тиnа IlleqalМoni torStateException, если поток исnолнения
	не владеет блокировкой данного объекта.
* void wait()
	Вынуждает nоток исnолнения ожидать уведомления в течение указанного периода времени. Вызывается
	только из синхронизированного метода или блока кода. Генерирует исключение тиnа
	IlleqalМonitorStateException, если поток исnолнения не владеет блокировкой данного
	объекта.
* void wait(lonq millis)
* void wait(lonq millis, int nanos)
	Вынуждают поток исnолнения ожидать уведомления в течение указанного периода времени. Вызываются
	только из синхронизированного метода или блока кода. Генерируют исключение тиnа
	IlleqalМonitorStateException, если nоток исnолнения не владеет блокировкой данного
	объекта. Задаваемое количество миллисекунд не может nревышать 1000000.

***************************************