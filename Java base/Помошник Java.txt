========================
ОБЩЕЕ
========================
final			final double SQR3 = 1.73				Объявление константы
static final		public static final double PI = 3.14			Константа класса
enum			enum Size {SMALL, MEDIUM, BIG };			Перечисление

(int)x			Приведение типов

Импорт модулей:
import static java.lang.Math.*;

System.out.println();	Вывод данных в консоль

Чтение данных из консоли - создается объект типа Scanner и связывается с потоком ввода:
Scanner in = new Scanner(System.in);

String name = in.nextLine();			// Чтение вводимой строки (может содержать пробелы)
String firstName = in.next();			// Чтение слова
nextInt();					// Чтение целочисленнного значения
nextDouble();					// С плавающей точкой

extends			(Наследует)		Используется для наследования класса от суперкласса
impliments		(Реализует)		Используется для включения интерфейса в класс
========================
Файловый ввод-вывод
========================
Включить пакет с классом Scanner:
import java.util.*;

Чтение из файла:
Scanner in = new Scanner(Path.of("myfile.txt"), StandartCharsets.UTF_8);
ПРи прописании косые черты дублируются: "c:\\mydirectory\\myfile.txt"

Запись в файл:
PrintWriter out = new PrintWriter("myfile.txt", StandartCharsets.UTF_8);
Для вывода в файл используются те же методы, что и в консоль:
print(), println(); printf().

Задание начальной папки для использования относительного пукти файла:
String dir = System.getPropetry("user.dir");

Для уведомления компиятора о возможности возникновения исключений при чтении или записи файлов
в метод main() добавить предложение throws:
public static void main(String[] args) throws IOException
{
	Scanner in = new Scanner(Path.of("myfile.txt"), StandartCharsets.UTF_8);
	...
}
========================
========================
БАЗОВЫЕ ТИПЫ
========================
byte
short
int
long
float
double
char
boolean
========================
ОПЕРАТОРЫ
========================
Название	Применение			Описание
	
this		this.count = 1			Использует копию переменной класса, в обход локальной переменной
class		public class NewClass {}	Создает новый класс
public
protected
private
static		static int x			Созздает переменную статической (один вариант для всех объектов класса)

Тернарный оператор
условие ? выражение_1 : выражение_2

break;		Выход из цикла
break с меткой;
continue;	Переход в начало цикла, минуя оставшуюся часть шага
		в цикле for: переход к инкременированию счетчика

=======================
МАССИВЫ
=======================
Создание массива:
int[] a = new int[100];		// или var a = new int[100];

Создание массива с одновременной инициализацией:
int[] smallPrimes = {2, 3, 5, 7, 11, 13};
a.length();		Длинна массива

Arrays.toString(a);
Выводит весь массив в строковом виде в формате [2, 4, 6...]

Копирование массива(всех элементов):
int[] copiedArr1 = Arrays.copyOf(arr1, arr1.length);

Сортировка массива:
Arrays.sort(a);		// где a - имя сортируемого массива.
Используется усовершенствованный алгоритм быстрой сортировки.

=======================
СПИСОЧНЫЕ МАССИВЫ
=======================
Класс: ArrayList

ArrayList<Employee>	(Тип даных указывается в угловых скобках)

Объявление:
ArrayList<Employee> staff = new ArrayList<Employee>();

Или лучше так:
var staff = new ArrayList<Employee>();

Для добавления элементов в списочный массив используется метод add().
Например:
staff.add(new Employee("Harry Hacker", ...));
staff.add(new Employee("Tony Tester", ...));

Если число элементов известно заранее,то перед заполнением досточно вызвать метод
ensureCapacity():
staff.ensureCapacity(100); 	// выделит память на 100 элементов
Или же передать конструктору число элементов
ArrayList<Employee> staff = new ArrayList<Employee>(100);

size();			Возвращает текущее количество элементов в массиве
staff.size();		

trimToSize();		Обрезает списочный массив до текущего размера элементов


Доступ к элементам списочного массива осуществляется через get() и set()
staf.set(i, harry);	// работает как a[i] = harry;

Получение элемента списочного массива:
Employee e = staff.get(i); // работает точно так же как Employee e = a[i];
========================
ЦИКЛЫ и ВЕТВЛЕНИЯ
========================
++++++++++++++++++++++++
	if
++++++++++++++++++++++++
Простая форма:
if (условие) оператор;
Например:
if (a > b)
{
	x = a;
	b++;
}

Общая форма:
if (условие) оператор;
else оператор;

Например:
if (a > b)
{
	x = a;
	b++;
}
else
{
	x = b;
}

Множественная форма:
if(условие1) оператор;
esle if(условие2) оператор;
else if(условие3) оператор;
else оператор;

Например:
if(a > b)
{
	x = a
}
else if(a = b)
{
	x = 0;
}
else
{
	x = b;
}
++++++++++++++++++++++++
++++++++++++++++++++++++
	while
++++++++++++++++++++++++
while(условие) оператор;

++++++++++++++++++++++++
++++++++++++++++++++++++
	do while
++++++++++++++++++++++++
do оператор while (условие)

Например:
do {
	x = b + a;	
} while (x < y);
++++++++++++++++++++++++
++++++++++++++++++++++++
	for
++++++++++++++++++++++++
for(инициализация; условие; итерация)
	оператор(ы);

Пример:
for(int i = 0; i <= 10; i++)
{
	x = i;
	System.out.println(x);
}
++++++++++++++++++++++++
++++++++++++++++++++++++
	for each
++++++++++++++++++++++++
Общая форма:
for(переменная : коллекция) оператор;

Например:
for(int element : a)
	System.out.println(element);
++++++++++++++++++++++++
++++++++++++++++++++++++
	Switch
++++++++++++++++++++++++
swicth(chice)
{
	case 1:
		...
		break;
	case 2:
		...
		break;
	case 3:
		...
		break;
	case 4:
		...
		break;
	default:
		...
		break;

}
++++++++++++++++++++++++
========================
========================
ОБРАБОТКА ИСКЛЮЧЕНИЙ
========================
try {
	// возможный сбойный код
} catch(Exception e) {
	// код для обработки исключений
}
+++++++++++++++
Общая форма:
+++++++++++++++
try
(
	КОД
	дополнительный код
	дополнительный код
catch (ТипИсключения е)
(
	обработчик исключений данного типа
}

+++++++++++++++++++++++++++++++++++++++
Для перехвата множества исключений:
+++++++++++++++++++++++++++++++++++++++
try
{
	код, способный генерировать исключения
catch (FileNotFoundException е)
{
	чрезвычайные действия, если отсутствуют нужные файлы
catch (UnknownHostException е)
{
	чрезвычайные действия, если хосты неизвестны
catch (IOException е)
{
	чрезвычайные действия во всех остальных
	случаях появления ошибок ввода-вывода
}

++++++++++++++++++
С блоком finally
++++++++++++++++++
InputStream in = new FileinputStream( ... );
try
{

	код, способный генерировать исключения

} catch (IOException е)
{
	вывести сообщение об опмбке
}
finally
{
	in.close();
}

+++++++++++++++++++++++
блок try с ресурсами
+++++++++++++++++++++++
открыть ресурс
try
{
	использовать ресурс
}
finally
{
	закрыть ресурс
}
========================
Класс Math (Математические функцкии)
========================
sqrt()		double x = Math.sqrt(y);		Вычисляет квадратный корень
pow()		double x = Math.pow(y, a);		Возводит число y  в степень a

Тригонометрические
Math.sin();
Math.cos();
Math.tan();
Math.atan();
Math.atan2();

Экспотенциальные и логарифмические функции
Math.exp();
Math.log();
Math.log10(0;

Константы
Math.PI
Math.E

round()			Округление
Например:
double x = 9.97;
int nx = (int)Math.round(x);			// nx становится равным 10

Math.random();		Возвращает случайное число с плавающей точкой в пределе от 0 до 1(исключительно).
Умножение результата на число n дает случайное число, в пределах от 0 до n-1.
int r = (int) (Math.random() * n);

========================
========================
ДАТА и ВРЕМЯ
========================
Класс стандартной библиотеки Date
Более предпочтительный класс LocalDate

LocalDate.now()		Создается новый объект
Его лучше сохранить в объектной переменной
LocalDate newYearsEve = LocalDate.of(1999, 12, 31);

Можно определить год, месяц и день с помощью методов getYear(), getMonthValue(), getDayOfMonth().
int year = newYearsEve.getYear();		// 1999г
int month = newYearsEve.getMonthValue();	// 12-й месяц
int day = newYearsEve.getDayOfMonth();		// 31-е число 
========================
========================
РАБОТА СО СТРОКАМИ
========================
String			Класс для строк

substring()				Копирует подстроку из строки
String s2 = s1.substring(0, 3);		Копирует символы в стоку s2 (символы с 0 по 2 (3 уже нет))
Второй аргумент также обозначает количество копируемых символов

+			Сцепление строк(соединение)
При сцеплении строки с другими значениями, например int, последние автоматически преобразуются в строковые

repeat()		rep = "Java".repeat(3);			Повторяет строку заданное количество раз
equals()		s1.equals(s2);				Сравнение строк на равенство. True, если равны, иначе false.
								Например можно и так: "HellO!".equals(s1);
equalsIgnoreCase();	"Hello".equalsIgnoreCase("hello");	Проверяте идентичность строк, игнорируя проп и стр.

StringBuilder		Класс для конструирования строк
Создаем объект 
StringBuilder builder = new StringBuilder();

А потом с помощью методов добавляем в него
builder.append(ch);	// Добавляет единственный символ
builder.append(str);	// Добавляет символьную строку

Завершив все добавления переводим в String
String completedString = builder.toString();

========================
========================
СЕРИАЛИЗАЦИЯ
========================
Запись сериализованного объекта в файл

1. Создаем объект FileOutputStream
FileOutputStream fileStream = new FileOutputStream("MyGame.ser);

2. Создаем ObjectOutputStream
ObjectOutputStream os = new ObjectOutputStream(fileStream);
ObjectOutputStream позволит записывать объекты, но не позволит напрямую подключаться к файлу.
Для этого связываются эти два потока. 

3.Записываем объект
os.writeObject(characterOne);
os.writeObject(characterTwo);
os.writeObject(characterThree);
Сериализуем объекты, ан которые указывают ссылки characterOne,characterTwo, characterThree 
и записываем их в файл MyGame.ser

4. Закрываем ObjectOutputStream.
os.close();
Закрывая поток верхнего уровня мы закрываем и исходный поток, так что FileOutputStream 
и файл закроются автоматически.

========================
ДЕСЕРИАЛИЗАЦИЯ
========================
1. Создаем FileInputStream
// Создаем объект FileInputStream. Он знает, как соединиться с существующим файлом. 
FileInputStream fileStream = new FileInputStream("MyGame.ser");

2. Создаем ObjectInputStream.
// Подключаемся к потоку
ObjectInputStream os = new ObjectInputStream(fileStream);

3. Читаем объекты.
Object one = os.readObject();
Object two = os.readObject();
Object three = os.readObject();

Каждый раз, когда мы вызвываем метод readObject(), мы получаем следующий объект в потоке. 
В итоге читаем их в том же порядке, в котором они были записаны. 
Мы получим большое исключючение, если попытаемся прочитать больше объектов, чем 
были записаны. 

4. Приводим объекты.
GameCharacter elf = (GameCharacter) one;
GameCharacter troll = (GameCharacter) two;
GameCharacter magician = (GameCharacter) three;

Возвращаемый объект метода readObject() имеет тип Object (как и из ArrayList), 
поэтому его нужно привести к требуемому типу. 

5. Закрываем ObjectInputStream.
os.close();
FileImputStream(и сам файл) при этом закрываются автоматически. 

========================
СЧИТЫВАНИЕ ДАННЫХ ИЗ СОКЕТА
========================
Для считывания данных из сокета используется BufferedRead

1.Создаем сокет и связываемся с сервером
Soket chatSocket = new Soket("127.0.0.1", 5000);	// ip адресс и номер порта

/* 127.0.0.1 - локальный IP адрес, то есть адресс компьютера, на котором выполняет код.
Его можно использовать при тестировании отдельных клиентов и серверов на отдельной машине */

2.Создаем InputStreamReader и связываем его с низкоуровневым потоком(соединением) через сокет. 
InputStreamReader stream = new InputStreamReader(chatSocket.getInputStream());

// InputStreamReader это мост, соединяющий		// Нужно лишь запросить у сокета входящий поток!
 низкоуровненый потток байтов (скажем, получаемый	Он низкоуровневый, мы прост осоединим его к объекту,
 из сокета) и выфсокоуровненый символьный поток		который лучше умеет работать с текстом.
(например предоставляемый BufferedRead, 
который находится на вершине цепочки)


3.Создаем BufferedRead и считываем данные
BufferedRead read = new BufferedRead(stream);
String message = reader.readLine();

/* В итоге мы подключаем BufferedRead к InputStreamReader(который в свою очередь подключен к низкоуровневому 
потоку из сокета) */

========================
ЗАПИСЬ ДАННЫХ В СОКЕТ
========================
Для записи данных в сокет используется PrintWriter

1.Создаем сокет и связываемся с сервером
Socket chatSocket = new Socket("127.0.0.1", 5000);

2.Создаем PrintWriter и связываем его с низкоуровневым исходящим потоком, полученным из сокета
PrintWriter writer = new PrintWriter(chatSocket.getOutputStream());

// PrintWriter это мост между 		// Сокет дает нам низкоуровневый поток, 
данными и байтами, которые получает	Мы передаем его в конструктор PrintWriter, 
из низкоуровневого исходящего 		слздавая цепочку.
потока и предоставляемого сокетом. 
Подключив PrintWriter к исходящему
 потоку, мы можем записывать строки
в сокет.

3.Записываем(выводим) что-нибудь.
writer.println("Сообщение для отправки");
writer.print("Другое сообщение");

========================
СОЗДАНИЕ ПРОСТОГО СЕРВЕРА
========================
1.Серверное приложение создает объект ServerSocket, указывая конкретный порт:
ServerSocket serverSock = new ServerSocket(4242);

Таким образом, сервер начинает отслеживать входящие клиентские запросы на порту 4242. 

2.Клиент создает сокет и связывается с серверным приложением:
Socket sock = new Socket("190.165.1.103", 4242);

Клиент знает IP-адрес и номер порта(опубликованные или переданные ему 
настройщиком сервера).

3.Сервер создает новый сокет для общения с этим клиентом:
Socket sock = serverSock.accept();

Метод accept() блокирует программу, пока ожидает подключения клиентского сокета. 
Когда клиент попытается подключиться, метод возвращает обычный объект Socket(на другом порту), 
который знает, как взаимодействовать с клиентом(т.е.знает его IP-адрес и номер порта). 
Порт, на котором работает Socket, отличается от порта ServerSocket: поэтому 
ServerSocket может дальше отслеживать новые подключения. 

*******************************************************************************
ООП
*******************************************************************************
========================
КЛАСС
========================
public class MyClass {
	// тело класса
}

Создание конструктора класса (Cabbie):
public Cabbie() 
{
	/* Код конструктора класса  */
}
========================
НАСЛЕДОВАНИЕ КЛАССА
========================
public class MyClass1 extends MyClass2 {
	// тело класса
}
========================
========================
ОБЪЕКТ
========================
Создание объекта класса (Cabbie):
Cabbie myCabbie = new Cabbie();

//Создает объект myCabbie класса Cabie;

clone();		Данный метод служит для получения полной копии объекта

========================
========================
ИНТЕРФЕЙС
========================
public interface showInfo 
{

}

========================
Включение интерфейса в класс
========================
public class myClass impliments showInfo
{

}
========================
ДОКУМЕНТИРОВАНИЕ КОДА
========================
@param описание переменной
	Добавляет в описание метода раздел параметров. Раздел параметров можно
	развернуть на несколько строк. Кроме того, можно использовать элементы
	НlМL-разметки. Все дескрипторы @param, относящиеся к одному методу,
	должны быть сгруппированы.

@return описание
	Добавляет в описание метода раздел возвращаемого значения. Этот раздел также
	может занимать несколько строк и допускает форматирование с помощью
	дескрипторов НТМL-разметки.

@throws описание класса
	Указывает на то, что метод способен генерировать исключение.

Пример:
/**
* Увеличивает зарплату работников
* @param Переменная byPerceпt содержит величину
* в процентах, на которую повышается зарплата
* (например, 10 = 10%).
* @returп Величина, на которую повышается зарплата
*/
public double raiseSalary(double byPercent)
{
double raise = salary * byPercent / 100;
salary += raise;
return raise;
}

В комментариях к классам можно использовать следующие дескрипторы.
* @author имя
	Создает раздел автора программы. В комментариях может быть несколько таких
	дескрипторов - по одному на каждого автора.
* since текст
	Создает раздел начальной точки отсчета. Здесь текст означает описание версии
	программы, в которой впервые был внедрен данный компонент. Например,
	@since version 1. 7 .1.
* @version текст
	Создает раздел версии программы. В данном случае текст означает произвольное
	описание текущей версии программы.
========================
АННОТАЦИИ
========================
@Override		Переопределяет соответствующий метод из суперкласса

*******************************************************************************

============================
КОЛЛЕКЦИИ ИЗ БИБЛИОТЕКИ JAVA
============================
ArrayList	Индексированная динамически расширяющаяся и сокращающаяся
		последовательность

LinkedList	Упорядоченная последовательность, допускающая эффективную вставку и удаление
		на любой позиции

ArrayDeque	Двунаправленная очередь, реализуемая в виде циклического массива

HashSet		Неупорядоченная коллекция, исключающая дубликаты

TreeSet		Отсортированное множество

EnumSet		Множество значений перечислимого типа

LinkedНashSet	Множество, запоминающее порядок ввода элементов

PriorityQueue	Коллекция, позволяющая эффективно удалять наименьший элемент

HashМap		Структура данных для хранения связанных вместе пар "ключ-значение"

ТrееМар		Отображение с отсортированными ключами

EnumМap		Отображение с ключами, относящимися к перечислимому типу

LinkedНashМap	Отображение с запоминанием порядка, в котором добавлялись элементы

WeakHashМap	Отображение со значениями, которые могут удаляться системой сб о рки " мусора",
		если они нигде больше не используются

IdentityHashМap	Отображение с ключами, сравниваемыми с помощью операции==. а не вызова
		метода equals ()
============================
*******************************************************************************