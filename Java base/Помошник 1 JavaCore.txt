========================
ОБЩЕЕ
========================
final			final double SQR3 = 1.73				Объявление константы
static final		public static final double PI = 3.14			Константа класса
enum			enum Size {SMALL, MEDIUM, BIG };			Перечисление

(int)x			Приведение типов

Импорт модулей:
import static java.lang.Math.*;

System.out.println();	Вывод данных в консоль

Чтение данных из консоли - создается объект типа Scanner и связывается с потоком ввода:
Scanner in = new Scanner(System.in);

String name = in.nextLine();			// Чтение вводимой строки (может содержать пробелы)
String firstName = in.next();			// Чтение слова
nextInt();					// Чтение целочисленнного значения
nextDouble();					// С плавающей точкой

extends			(Наследует)		Используется для наследования класса от суперкласса
impliments		(Реализует)		Используется для включения интерфейса в класс
========================
Файловый ввод-вывод
========================
Включить пакет с классом Scanner:
import java.util.*;

Чтение из файла:
Scanner in = new Scanner(Path.of("myfile.txt"), StandartCharsets.UTF_8);
ПРи прописании косые черты дублируются: "c:\\mydirectory\\myfile.txt"

Запись в файл:
PrintWriter out = new PrintWriter("myfile.txt", StandartCharsets.UTF_8);
Для вывода в файл используются те же методы, что и в консоль:
print(), println(); printf().

Задание начальной папки для использования относительного пукти файла:
String dir = System.getPropetry("user.dir");

Для уведомления компиятора о возможности возникновения исключений при чтении или записи файлов
в метод main() добавить предложение throws:
public static void main(String[] args) throws IOException
{
	Scanner in = new Scanner(Path.of("myfile.txt"), StandartCharsets.UTF_8);
	...
}
========================
========================
БАЗОВЫЕ ТИПЫ
========================
byte
short
int
long
float
double
char
boolean
========================
ОПЕРАТОРЫ
========================
Название	Применение			Описание
	
this		this.count = 1			Использует копию переменной класса, в обход локальной переменной
class		public class NewClass {}	Создает новый класс
public
protected
private
static		static int x			Созздает переменную статической (один вариант для всех объектов класса)

Тернарный оператор
условие ? выражение_1 : выражение_2

break;		Выход из цикла
break с меткой;
continue;	Переход в начало цикла, минуя оставшуюся часть шага
		в цикле for: переход к инкременированию счетчика

=======================
МАССИВЫ
=======================
Создание массива:
int[] a = new int[100];		// или var a = new int[100];

Создание массива с одновременной инициализацией:
int[] smallPrimes = {2, 3, 5, 7, 11, 13};
a.length();		Длинна массива

Arrays.toString(a);
Выводит весь массив в строковом виде в формате [2, 4, 6...]

Копирование массива(всех элементов):
int[] copiedArr1 = Arrays.copyOf(arr1, arr1.length);

Сортировка массива:
Arrays.sort(a);		// где a - имя сортируемого массива.
Используется усовершенствованный алгоритм быстрой сортировки.

=======================
СПИСОЧНЫЕ МАССИВЫ
=======================
Класс: ArrayList

ArrayList<Employee>	(Тип даных указывается в угловых скобках)

Объявление:
ArrayList<Employee> staff = new ArrayList<Employee>();

Или лучше так:
var staff = new ArrayList<Employee>();

Для добавления элементов в списочный массив используется метод add().
Например:
staff.add(new Employee("Harry Hacker", ...));
staff.add(new Employee("Tony Tester", ...));

Если число элементов известно заранее,то перед заполнением досточно вызвать метод
ensureCapacity():
staff.ensureCapacity(100); 	// выделит память на 100 элементов
Или же передать конструктору число элементов
ArrayList<Employee> staff = new ArrayList<Employee>(100);

size();			Возвращает текущее количество элементов в массиве
staff.size();		

trimToSize();		Обрезает списочный массив до текущего размера элементов


Доступ к элементам списочного массива осуществляется через get() и set()
staf.set(i, harry);	// работает как a[i] = harry;

Получение элемента списочного массива:
Employee e = staff.get(i); // работает точно так же как Employee e = a[i];
========================
ЦИКЛЫ и ВЕТВЛЕНИЯ
========================
++++++++++++++++++++++++
	if
++++++++++++++++++++++++
Простая форма:
if (условие) оператор;
Например:
if (a > b)
{
	x = a;
	b++;
}

Общая форма:
if (условие) оператор;
else оператор;

Например:
if (a > b)
{
	x = a;
	b++;
}
else
{
	x = b;
}

Множественная форма:
if(условие1) оператор;
esle if(условие2) оператор;
else if(условие3) оператор;
else оператор;

Например:
if(a > b)
{
	x = a
}
else if(a = b)
{
	x = 0;
}
else
{
	x = b;
}
++++++++++++++++++++++++
++++++++++++++++++++++++
	while
++++++++++++++++++++++++
while(условие) оператор;

++++++++++++++++++++++++
++++++++++++++++++++++++
	do while
++++++++++++++++++++++++
do оператор while (условие)

Например:
do {
	x = b + a;	
} while (x < y);
++++++++++++++++++++++++
++++++++++++++++++++++++
	for
++++++++++++++++++++++++
for(инициализация; условие; итерация)
	оператор(ы);

Пример:
for(int i = 0; i <= 10; i++)
{
	x = i;
	System.out.println(x);
}
++++++++++++++++++++++++
++++++++++++++++++++++++
	for each
++++++++++++++++++++++++
Общая форма:
for(переменная : коллекция) оператор;

Например:
for(int element : a)
	System.out.println(element);
++++++++++++++++++++++++
++++++++++++++++++++++++
	Switch
++++++++++++++++++++++++
swicth(chice)
{
	case 1:
		...
		break;
	case 2:
		...
		break;
	case 3:
		...
		break;
	case 4:
		...
		break;
	default:
		...
		break;

}
++++++++++++++++++++++++
========================
========================
ОБРАБОТКА ИСКЛЮЧЕНИЙ
========================
try {
	// возможный сбойный код
} catch(Exception e) {
	// код для обработки исключений
}
+++++++++++++++
Общая форма:
+++++++++++++++
try
(
КОД
дополнительный код
дополнительный код
catch (ТипИсключения е)
(
обработчик исключений данного типа
}

+++++++++++++++++++++++++++++++++++++++
Для перехвата множества исключений:
+++++++++++++++++++++++++++++++++++++++
try
{
код, способный генерировать исключения
catch (FileNotFoundException е)
{
чрезвычайные действия, если отсутствуют нужные файлы
catch (UnknownHostException е)
{
чрезвычайные действия, если хосты неизвестны
catch (IOException е)
{
чрезвычайные действия во всех остальных
случаях появления ошибок ввода-вывода
}

++++++++++++++++++
С блоком finally
++++++++++++++++++
InputStream in = new FileinputStream( ... );
try
{
11 1
код, способный генерировать исключения
11 2
catch (IOException е)
{
11 3
вывести сообщение об опмбке
11 4
finally
{
)
11 5
in.close();
11 6

+++++++++++++++++++++++
блок try с ресурасми
+++++++++++++++++++++++
открыть ресурс
try
(
использовать ресурс
finally
(
закрыть ресурс
}
========================
Класс Math (Математические функцкии)
========================
sqrt()		double x = Math.sqrt(y);		Вычисляет квадратный корень
pow()		double x = Math.pow(y, a);		Возводит число y  в степень a

Тригонометрические
Math.sin();
Math.cos();
Math.tan();
Math.atan();
Math.atan2();

Экспотенциальные и логарифмические функции
Math.exp();
Math.log();
Math.log10(0;

Константы
Math.PI
Math.E

round()			Округление
Например:
double x = 9.97;
int nx = (int)Math.round(x);			// nx становится равным 10

Math.random();		Возвращает случайное число с плавающей точкой в пределе от 0 до 1(исключительно).
Умножение результата на число n дает случайное число, в пределах от 0 до n-1.
int r = (int) (Math.random() * n);

========================
========================
ДАТА и ВРЕМЯ
========================
Класс стандартной библиотеки Date
Более предпочтительный класс LocalDate

LocalDate.now()		Создается новый объект
Его лучше сохранить в объектной переменной
LocalDate newYearsEve = LocalDate.of(1999, 12, 31);

Можно определить год, месяц и день с помощью методов getYear(), getMonthValue(), getDayOfMonth().
int year = newYearsEve.getYear();		// 1999г
int month = newYearsEve.getMonthValue();	// 12-й месяц
int day = newYearsEve.getDayOfMonth();		// 31-е число 
========================
========================
РАБОТА СО СТРОКАМИ
========================
String			Класс для строк

substring()				Копирует подстроку из строки
String s2 = s1.substring(0, 3);		Копирует символы в стоку s2 (символы с 0 по 2 (3 уже нет))
Второй аргумент также обозначает количество копируемых символов

+			Сцепление строк(соединение)
При сцеплении строки с другими значениями, например int, последние автоматически преобразуются в строковые

repeat()		rep = "Java".repeat(3);			Повторяет строку заданное количество раз
equals()		s1.equals(s2);				Сравнение строк на равенство. True, если равны, иначе false.
								Например можно и так: "HellO!".equals(s1);
equalsIgnoreCase();	"Hello".equalsIgnoreCase("hello");	Проверяте идентичность строк, игнорируя проп и стр.

StringBuilder		Класс для конструирования строк
Создаем объект 
StringBuilder builder = new StringBuilder();

А потом с помощью методов добавляем в него
builder.append(ch);	// Добавляет единственный символ
builder.append(str);	// Добавляет символьную строку

Завершив все добавления переводим в String
String completedString = builder.toString();

========================

*******************************************************************************
ООП
*******************************************************************************
========================
КЛАСС
========================
public class MyClass {
	// тело класса
}

Создание конструктора класса (Cabbie):
public Cabbie() 
{
	/* Код конструктора класса  */
}
========================
НАСЛЕДОВАНИЕ КЛАССА
========================
public class MyClass1 extends MyClass2 {
	// тело класса
}
========================
========================
ОБЪЕКТ
========================
Создание объекта класса (Cabbie):
Cabbie myCabbie = new Cabbie();

//Создает объект myCabbie класса Cabie;

clone();		Данный метод служит для получения полной копии объекта

========================
========================
ИНТЕРФЕЙС
========================
public interface showInfo 
{

}

========================
Включение интерфейса в класс
========================
public class myClass impliments showInfo
{

}
========================
КОММЕНТИРОВАНИЕ КОДА
========================
@param описание переменной
	Добавляет в описание метода раздел параметров. Раздел параметров можно
	развернуть на несколько строк. Кроме того, можно использовать элементы
	НlМL-разметки. Все дескрипторы @param, относящиеся к одному методу,
	должны быть сгруппированы.

@return описание
	Добавляет в описание метода раздел возвращаемого значения. Этот раздел также
	может занимать несколько строк и допускает форматирование с помощью
	дескрипторов НТМL-разметки.

@throws описание класса
	Указывает на то, что метод способен генерировать исключение.

Пример:
/**
* Увеличивает зарплату работников
* @param Переменная byPerceпt содержит величину
* в процентах, на которую повышается зарплата
* (например, 10 = 10%).
* @returп Величина, на которую повышается зарплата
*/
public double raiseSalary(double byPercent)
{
double raise = salary * byPercent / 100;
salary += raise;
return raise;
}

В комментариях к классам можно использовать следующие дескрипторы.
* @author имя
	Создает раздел автора программы. В комментариях может быть несколько таких
	дескрипторов - по одному на каждого автора.
* since текст
	Создает раздел начальной точки отсчета. Здесь текст означает описание версии
	программы, в которой впервые был внедрен данный компонент. Например,
	@since version 1. 7 .1.
* @version текст
	Создает раздел версии программы. В данном случае текст означает произвольное
	описание текущей версии программы.
========================
АННОТАЦИИ
========================
@Override		Переопределяет соответствующий метод из суперкласса

*******************************************************************************

============================
КОЛЛЕКЦИИ ИЗ БИБЛИОТЕКИ JAVA
============================
ArrayList	Индексированная динамически расширяющаяся и сокращающаяся
		последовательность

LinkedList	Упорядоченная последовательность, допускающая эффективную вставку и удаление
		на любой позиции

ArrayDeque	Двунаправленная очередь, реализуемая в виде циклического массива

HashSet		Неупорядоченная коллекция, исключающая дубликаты

TreeSet		Отсортированное множество

EnumSet		Множество значений перечислимого типа

LinkedНashSet	Множество, запоминающее порядок ввода элементов

PriorityQueue	Коллекция, позволяющая эффективно удалять наименьший элемент

HashМap		Структура данных для хранения связанных вместе пар "ключ-значение"

ТrееМар		Отображение с отсортированными ключами

EnumМap		Отображение с ключами, относящимися к перечислимому типу

LinkedНashМap	Отображение с запоминанием порядка, в котором добавлялись элементы

WeakHashМap	Отображение со значениями, которые могут удаляться системой сборки "мусора",
		если они нигде больше не используются

IdentityHashМap	Отображение с ключами, сравниваемыми с помощью операции ==. а не вызова
		метода equals()
============================
*******************************************************************************