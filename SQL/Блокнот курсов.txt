=====================================
Автоматическая генерация поля ID
=====================================
1. В базе данных создается sequence(последовательность), ему присваивается имя.

Например: 
CREATE SEQUENCE first_sequence

Sequence - этой объект базы данных, выдающий целые числа по порядку.
Чтобы получить эти значения:

SELECT NEXTVAL('first_sequence')
Каждый раз счетчик значения будет увеличиваться.

И потом генерировать значения id(уникальное) уже запросом из программы.

Чтобы удалить sequence:
DROP SEQUENCE first_sequence

Чтобы колонка получала номер автоматически в Postgres используется 
специальный тип данных, называемый serial.

Создаем таблицу с таким ID:
create table Person(
    id SERIAL,
    name varchar,
    age int,
    email varchar
)

При этом postgres создает и таблицу и sequence.

После этого запрос к бд пишем вроде(старый синтаксис):
insert into person(name, age, email) VALUES('Garry', 33, 'garry@inbox.ru')
и поле id генерируется автоматически.

Но лучше использовать такой запрос:
create table person(
	id int GENERATED BY DEFAULT AS IDENTITY,
	name varchar,
	age int,
	email varchar
)
=====================================
Ограничения полей
=====================================

NOT NULL	Поле не может быть пустым
UNIQUE		Уникальное значение, не может повторяться

PRIMARY KEY	Первичный ключ (NOT NULL + UNIQUE)
FOREIGN KEY	Внешний ключ

CHECK		Ограничение по значению(например > 0)

Например таблица с ограничениями:
create table person(
	id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	name varchar NOT NULL, 
	age int check (age > 0),
	email varchar UNIQUE
)

*************************************

=====================================
Объединений таблиц
=====================================
*************
Inner Join
*************
Будут помещены все значения левой таблицы которые нашли совпадение в правой таблице.
Которых нет в правой не будут отражены в левой. Подходит для отношений "один ко многим".

SELECT FROM Person JOIN Order ON Person.user_id = Order.user_id;

*************
Outer Join (Left)
*************
Здесь будут помещены все значения левой таблицы, независимо от того, есть ли у них совпадения 
в правой таблице. 

SELECT FROM Person LEFT JOIN Order ON Person.user_id = Order.user_id

Right Join не используется. Он делает все тоже что Left Join, только меняет таблицы местами.
Его можно выразить через Left Join, поменяв таблицы местами.

Есть еще Cross Join(Декартовый), он совсем не используется. 
Просто ставит каждую строку таблицы А с каждой строкой таблицы Б.

*************************************

=====================================
Создание и объединение таблиц: практика
=====================================
Добавление данных в таблицу Person:

INSERT INTO Person(name, age, email) VALUES('Tom', 34, 'tom@mail.ru');
INSERT INTO Person(name, age, email) VALUES('Bob', 23, 'bobi@gmail.com');
INSERT INTO Person(name, age, email) VALUES('Katty', 22, 'katy@inbox.ru');


///////////////////////////////////////////////////////////////////////////
Отношения один ко многим
///////////////////////////////////////////////////////////////////////////

**********************
Таблица режиссеров
**********************
create table Director(
    director_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name varchar(100) NOT NULL UNIQUE,
    age int CHECK ( age > 10 )
)

**********************
Таблица фильмов
**********************
create table Movie(
    movie_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    director_id int NOT NULL REFERENCES director(director_id),
    name varchar(200) NOT NULL,
    year_of_production int CHECK ( year_of_production > 1900 )
)

Добавление данных в таблицу Director:
INSERT INTO Director(name, age) VALUES('Quentin Tarantino', 57);
INSERT INTO Director(name, age) VALUES('Martin Scorsese', 78);
INSERT INTO Director(name, age) VALUES('Guy Ritchie', 52);
INSERT INTO Director(name, age) VALUES('Woody Allen', 85);
INSERT INTO Director(name, age) VALUES('David Lunch', 74);
INSERT INTO Director(name, age) VALUES('Christopher Nolan', 50);


Добавление данных в таблицу Movie:

INSERT INTO movie(director_id, name, year_of_production) VALUES (1, 'Reservoir Dogs', 1992);
INSERT INTO movie(director_id, name, year_of_production) VALUES (1, 'Pulp Fiction', 1994);
INSERT INTO movie(director_id, name, year_of_production) VALUES (1, 'The Hateful Eight', 2015);
INSERT INTO movie(director_id, name, year_of_production) VALUES (1, 'Once Upon a Time in Hollywood', 2019);
INSERT INTO movie(director_id, name, year_of_production) VALUES (2, 'Taxi Driver', 1976);
INSERT INTO movie(director_id, name, year_of_production) VALUES (2, 'Goodfellas', 1990);
INSERT INTO movie(director_id, name, year_of_production) VALUES (2, 'The Wolf of Wall Street', 2013);
INSERT INTO movie(director_id, name, year_of_production) VALUES (3, 'Lock, Stock and Two Smoking Barrels', 1998);
INSERT INTO movie(director_id, name, year_of_production) VALUES (3, 'Snatch', 2000);
INSERT INTO movie(director_id, name, year_of_production) VALUES (4, 'Midnight in Paris', 2011);
INSERT INTO movie(director_id, name, year_of_production) VALUES (6, 'Inception', 2010);

********************
Пример JOINa:
********************

Inner JOIN:

SELECT * FROM director JOIN movie on director.director_id = movie.director_id;
SELECT Director.name, Movie.name FROM director JOIN movie on director.director_id = movie.director_id;

Left Outer Join:

SELECT Director.name, Movie.name FROM director LEFT JOIN movie on director.director_id = movie.director_id;

///////////////////////////////////////////////////////////////////////////
Примеры отношений "Один к одному"
///////////////////////////////////////////////////////////////////////////

Создадим таблицу гражданина:

CREATE TABLE Citizen(
    citizen_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name varchar(100) NOT NULL,
    age int CHECK ( age > 0 )
);

Создадим таблицу паспорта:

CREATE TABLE Passport(
    citizen_id int PRIMARY KEY REFERENCES citizen(citizen_id),
    passport_number int
);

Добавляем граждан и паспорта:

INSERT INTO citizen(name, age) VALUES ('Bob', 12);
INSERT INTO citizen(name, age) VALUES ('Tom', 24);
INSERT INTO citizen(name, age) VALUES ('Katy', 39);
INSERT INTO citizen(name, age) VALUES ('Alice', 45);
INSERT INTO citizen(name, age) VALUES ('Jane', 1);

INSERT INTO passport(citizen_id, passport_number) VALUES (1, 12345);
INSERT INTO passport(citizen_id, passport_number) VALUES (2, 75124);
INSERT INTO passport(citizen_id, passport_number) VALUES (3, 91245);
INSERT INTO passport(citizen_id, passport_number) VALUES (4, 19259);


Делаем Inner JOIN:

SELECT name, passport_number FROM citizen JOIN passport on citizen.citizen_id = passport.citizen_id;

Делаем Left JOIN:

SELECT name, passport_number FROM citizen LEFT JOIN passport on citizen.citizen_id = passport.citizen_id;

///////////////////////////////////////////////////////////////////////////
Примеры отношений "Многие ко многим"
///////////////////////////////////////////////////////////////////////////

Создадим таблицу актеров:

CREATE TABLE Actor(
  actor_id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name varchar(100) NOT NULL UNIQUE,
  age int CHECK (age > 0)
);

Добавим актеров:

INSERT INTO actor(name, age) VALUES ('Harvey Keytel', 81);
INSERT INTO actor(name, age) VALUES ('Robert De Niro', 77);
INSERT INTO actor(name, age) VALUES ('Leonardo DiCaprio', 46);
INSERT INTO actor(name, age) VALUES ('Jason Statham', 53);
INSERT INTO actor(name, age) VALUES ('Joe Pesci', 77);
INSERT INTO actor(name, age) VALUES ('Samuel L.Jackson', 72);

Создаем связывающую таблицу:

CREATE TABLE Actor_Movie(
    actor_id int REFERENCES actor(actor_id),
    movie_id int REFERENCES movie(movie_id),
    PRIMARY KEY (actor_id, movie_id)
);

Заполняем связывающую таблицу:

INSERT INTO actor_movie VALUES (1, 1);
INSERT INTO actor_movie VALUES (1, 2);
INSERT INTO actor_movie VALUES (2, 5);
INSERT INTO actor_movie VALUES (2, 6);
INSERT INTO actor_movie VALUES (3, 4);
INSERT INTO actor_movie VALUES (3, 7);
INSERT INTO actor_movie VALUES (3, 11);
INSERT INTO actor_movie VALUES (4, 8);
INSERT INTO actor_movie VALUES (4, 9);
INSERT INTO actor_movie VALUES (5, 6);
INSERT INTO actor_movie VALUES (6, 2);
INSERT INTO actor_movie VALUES (6, 3);

Объединение (нужно будет 2 джойна)):

SELECT Actor.name, Movie.name FROM actor JOIN actor_movie
    on actor.actor_id = actor_movie.actor_id JOIN movie
        on actor_movie.movie_id = movie.movie_id;



///////////////////////////////////////////////////////////////////////////
ИНДЕКСЫ в БД
///////////////////////////////////////////////////////////////////////////

CREATE INDEX ON table(name) USING ???

PRIMARY KEY - индекс по умолчанию;
B-Tree Index - использует структуру данных B-дерево
Hash Index
Gin & Gist Insex - используются для текстовых колонок
BRIN Index



///////////////////////////////////////////////////////////////////////////
КАСКАДИРОВАНИЕ
///////////////////////////////////////////////////////////////////////////

user_id int REFERENCES Person(user_id) ON DELETE CASCADE


CASCADE - удаляет строки в зависимой таблице при удалении связанных строк 
			в главной таблице(удалили человека -> удаляются все связанные с ним заказы.
			
SET_NULL - выставляет значение внешнего ключа равным NULL при удалении 
			связанных строк в главной таблице(удалили человека -> теперь заказы ничейные)
			
RESTRICT - поведение по умолчанию. Выдает ошибку при попытке удалить человека. 




















